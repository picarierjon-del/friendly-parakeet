<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>WhatsApp → Comanda Smart</title>
  <style>
    :root { --b:#e5e7eb; --t:#111827; --m:#6b7280; }
    body{font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:14px;color:var(--t);max-width:980px}
    h1{font-size:20px;margin:0 0 8px}
    .small{font-size:12px;color:var(--m)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width: 860px){ .grid{grid-template-columns:1.05fr 0.95fr} }
    .card{border:1px solid var(--b);border-radius:14px;padding:12px}
    textarea{width:100%;min-height:260px;padding:12px;font-size:15px;border:1px solid var(--b);border-radius:12px}
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
    button{
      padding:12px 14px;border:1px solid var(--b);border-radius:12px;background:#fff;cursor:pointer;
      font-size:15px; -webkit-tap-highlight-color: transparent;
    }
    button:active{transform:scale(0.99)}
    .primary{border-color:#111827}
    details summary{cursor:pointer;font-weight:700}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}
    .box{white-space:pre-wrap;line-height:1.25;font-size:14px}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 10px}
    .tab{padding:10px 12px;border:1px solid var(--b);border-radius:12px;cursor:pointer;background:#fff}
    .tab.active{border-color:#111827}
    .pill{display:inline-block;padding:2px 10px;border:1px solid var(--b);border-radius:999px;font-size:12px}
    .ok{color:#166534}
    .warn{color:#b45309}
  </style>
</head>
<body>
  <div class="row">
    <div>
      <h1>WhatsApp → Comanda Smart</h1>
      <div class="small">iPhone-friendly: incolla ordine → genera → copia/stampa.</div>
    </div>
    <span id="dayBadge" class="pill">—</span>
  </div>

  <div class="grid">
    <div class="card no-print">
      <h3 style="margin:0 0 8px">Incolla ordine WhatsApp</h3>
      <textarea id="input" placeholder="Esempio:
Buonasera, vorrei ordinare 3 pizze margherita a domicilio, se possibile per le 19:30
Nome: Tura
Indirizzo: Via Nazioni Unite 2, Bagnolo Mella

Oppure:
Buonasera, vorrei prenotare 2 pizze a domicilio per le 20:00.
1 profumo di langa
1 quella della suocera
Via Agostino Gallo 58, Bagnolo Mella
Campanello: Lippolis - D’Orfeo
Grazie"></textarea>

      <div class="btns">
        <button id="gen" class="primary">Genera</button>
        <button id="copy">Copia</button>
        <button id="print">Stampa</button>
        <button id="closeDay">Chiusura serale</button>
      </div>

      <details>
        <summary>Catalogo (prezzi, extra, impasti, formati, alias)</summary>
        <div class="small" style="margin:8px 0">
          Modifica e salva. Le pizze “fantasia” (es. “profumo di langa”) vanno messe in <b>pizzas</b> o in <b>aliases</b>.
        </div>
        <textarea id="catalog" class="mono" style="min-height:340px"></textarea>
        <div class="btns">
          <button id="saveCatalog">Salva catalogo</button>
          <button id="resetCatalog">Ripristina esempio</button>
        </div>
        <div id="catStatus" class="small"></div>
      </details>
    </div>

    <div class="card">
      <div class="tabs">
        <div class="tab active" data-view="kitchen">Comanda cucina</div>
        <div class="tab" data-view="receipt">Ricevuta cliente</div>
      </div>

      <div id="outKitchen" class="mono box">—</div>
      <div id="outReceipt" class="mono box" style="display:none">—</div>

      <div id="status" class="small"></div>
    </div>
  </div>

<script>
/* ---------------- Storage ---------------- */
const LS = { catalog: "wa_catalog_smart_v1", lastDay: "wa_last_day_smart_v1" };

/* ---------------- Helpers ---------------- */
function todayKey(){
  const d = new Date();
  const pad = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
}
function nowStr(){
  const d = new Date();
  const pad = n => String(n).padStart(2,'0');
  return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
}
function normalizeTime(t){
  const m = t.match(/(\d{1,2})[.:](\d{2})/);
  if(!m) return '';
  const hh = String(Number(m[1])).padStart(2,'0');
  return `${hh}:${m[2]}`;
}
function stripChatNoise(line){
  return line.replace(/\s+\d{1,2}:\d{2}\s*$/,'').trim();
}
function money(n){ return (Math.round((n + Number.EPSILON) * 100) / 100).toFixed(2); }
function safeLower(s){ return (s||"").toLowerCase(); }
function normSpaces(s){ return (s||"").replace(/\s+/g,' ').trim(); }
function setStatus(msg, type=""){
  const el = document.getElementById("status");
  el.className = "small " + (type==="ok" ? "ok" : type==="warn" ? "warn" : "");
  el.textContent = msg || "";
}
function ensureDaily(){
  const t = todayKey();
  document.getElementById("dayBadge").textContent = `Giorno: ${t}`;
  const last = localStorage.getItem(LS.lastDay);
  if(last !== t){
    localStorage.setItem(LS.lastDay, t);
    setStatus("Nuovo giorno: pronto.", "ok");
  }
}

/* ---------------- Catalog sample ---------------- */
const SAMPLE_CATALOG = {
  currency: "€",
  rules: {
    deliveryFee: 0.00,
    halfHalfPricing: "max",  // "max" o "avg"
    halfHalfExtras: "full"   // "full" o "half"
  },
  pizzas: {
    "margherita": 6.00,
    "diavola": 7.50,
    "prosciutto": 7.50,
    "salame piccante": 7.50,
    "salsiccia porcini e grana": 9.50
    /* aggiungi qui: "profumo di langa": 10.00, "quella della suocera": 9.50 ... */
  },
  drinks: {
    "coca cola 33": 2.50,
    "coca cola 1.5": 4.00,
    "acqua 0.5": 1.50,
    "birra 33": 3.50
  },
  extras: {
    "speck": 1.50,
    "brie": 1.50,
    "porcini": 2.00,
    "grana": 1.00,
    "cipolla": 0.80
  },
  doughs: {
    "classico": 0.00,
    "integrale": 1.00,
    "senza glutine": 3.00
  },
  sizes: {
    "normale": 0.00,
    "baby": -1.00,
    "maxi": 2.00
  },
  aliases: {
    "marg": "margherita",
    "margherita": "margherita",
    "diavola": "diavola",
    "prosciutto": "prosciutto",
    "salame piccante": "salame piccante",

    "coca": "coca cola 33",
    "cocacola": "coca cola 33",
    "coca cola": "coca cola 33",
    "coca cola 33cl": "coca cola 33",
    "acqua": "acqua 0.5",

    "sg": "senza glutine",
    "s.g.": "senza glutine",
    "senza glutine": "senza glutine"
  }
};

function loadCatalog(){
  const saved = localStorage.getItem(LS.catalog);
  if(saved){
    try { return JSON.parse(saved); } catch {}
  }
  return structuredClone(SAMPLE_CATALOG);
}
function saveCatalog(obj){
  localStorage.setItem(LS.catalog, JSON.stringify(obj, null, 2));
}
function setCatalogTextarea(obj){
  document.getElementById("catalog").value = JSON.stringify(obj, null, 2);
}

/* ---------------- Field extraction ---------------- */
function extractLabeled(text, label){
  // label: "Nome", "Indirizzo", "Campanello"
  const re = new RegExp(`\\b${label}\\s*:\\s*(.+)$`, "im");
  const m = text.match(re);
  return m ? normSpaces(m[1]) : "";
}

function looksLikeAddress(line){
  const l = safeLower(line).trim();
  // oppure righe che iniziano con "indirizzo:"
  if(/^indirizzo\s*:/.test(l)) return true;
  return /^(via|viale|piazza|corso|strada|v\.|p\.|c\.so)\b/.test(l);
}

function detectPickupDelivery(text){
  const t = safeLower(text);
  const hasDelivery = /\b(consegna|domicilio|a casa|delivery)\b/.test(t);
  const hasPickup = /\b(ritiro|asporto|take away|takeaway)\b/.test(t);
  if(hasDelivery && !hasPickup) return "CONSEGNA";
  if(hasPickup && !hasDelivery) return "RITIRO";
  if(hasDelivery && hasPickup) return "CONSEGNA/RITIRO";
  return "";
}

function resolveAlias(cat, raw){
  const k = normSpaces(safeLower(raw));
  if(cat.aliases && cat.aliases[k]) return cat.aliases[k];
  return k;
}

function extractQtyAndText(line){
  let m = line.match(/^(\d+)\s+(.+)$/);
  if(m) return { qty: Number(m[1]), text: m[2].trim() };
  m = line.match(/^(.+?)\s*[x×]\s*(\d+)$/i);
  if(m) return { qty: Number(m[2]), text: m[1].trim() };
  return { qty: 1, text: line.trim() };
}

/* --- NEW: parse "3 pizze margherita" in one sentence --- */
function findInlinePizzaStatements(cat, text){
  // Cerca pattern: "3 pizze margherita" / "2 pizza diavola"
  // prende la parte dopo "pizze/pizza" fino a virgola o "a" (a domicilio) o fine.
  const out = [];
  const re = /\b(\d{1,2})\s*pizz[ae]\s+([a-zàèéìòù0-9'\- ]{2,})(?=,|\b(a|per|al|alla|a\s+domicilio|domicilio|ritiro|asporto)\b|$)/gi;
  let m;
  while((m = re.exec(text)) !== null){
    const qty = Number(m[1]);
    const nameRaw = normSpaces(m[2]);
    if(!nameRaw) continue;
    const nameKey = findPizzaName(cat, nameRaw);
    out.push({ qty, nameKey });
  }
  return out;
}

function parseHalfHalf(text){
  const t = normSpaces(text);
  if(!/met[àa]\s*e\s*met[àa]/i.test(t) && !/\bmezza\s+e\s+mezza\b/i.test(t) && !/\b1\/2\b/.test(t)) return null;
  let rest = t;
  const mm = t.match(/(met[àa]\s*e\s*met[àa]|mezza\s+e\s+mezza|1\/2)\s*(.+)$/i);
  if(mm) rest = mm[2].trim();
  const parts = rest.split(/\s*\/\s*|\s*\+\s*|\s+e\s+/i).map(s=>s.trim()).filter(Boolean);
  if(parts.length >= 2) return { a: parts[0], b: parts[1] };
  return null;
}

function parseExtrasAndRemovals(cat, text){
  const extras = [];
  const removals = [];

  const plus = [...text.matchAll(/(?:^|\s)\+\s*([a-zàèéìòù0-9'\- ]{2,})/gi)].map(m=>normSpaces(m[1]));
  const minus = [...text.matchAll(/(?:^|\s)-\s*([a-zàèéìòù0-9'\- ]{2,})/gi)].map(m=>normSpaces(m[1]));
  plus.forEach(p=>extras.push(resolveAlias(cat, p)));
  minus.forEach(p=>removals.push(resolveAlias(cat, p)));

  const senza = [...text.matchAll(/\bsenza\s+([a-zàèéìòù0-9'\- ]{2,})/gi)].map(m=>normSpaces(m[1]));
  senza.forEach(s=>{
    if(resolveAlias(cat, s) === "senza glutine") return;
    removals.push(resolveAlias(cat, s));
  });

  const con = [...text.matchAll(/\bcon\s+([a-zàèéìòù0-9'\- ,]+)$/gi)].map(m=>normSpaces(m[1]));
  con.forEach(c=>{
    c.split(/\s+e\s+|,/i).map(x=>normSpaces(x)).filter(Boolean).forEach(x=>{
      if(resolveAlias(cat, x) === "senza glutine") return;
      extras.push(resolveAlias(cat, x));
    });
  });

  // extra impliciti (se presenti nel testo)
  const lower = safeLower(text);
  for(const ex of Object.keys(cat.extras||{})){
    const exL = safeLower(ex);
    if(lower.includes(exL)){
      if(new RegExp(`\\bsenza\\s+${exL.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}\\b`).test(lower)) continue;
      if(!extras.includes(ex)) extras.push(ex);
    }
  }

  const uniq = arr => [...new Set(arr)];
  return { extras: uniq(extras), removals: uniq(removals) };
}

function detectDough(cat, text){
  if(/\b(senza\s+glutine|sg|s\.g\.)\b/i.test(text)) return "senza glutine";
  const lower = safeLower(text);
  for(const d of Object.keys(cat.doughs||{})){
    if(d==="senza glutine") continue;
    if(lower.includes(safeLower(d))) return d;
  }
  return "classico";
}
function detectSize(cat, text){
  const lower = safeLower(text);
  for(const s of Object.keys(cat.sizes||{})){
    if(s==="normale") continue;
    if(lower.includes(safeLower(s))) return s;
  }
  return "normale";
}

function findPizzaName(cat, text){
  let t = normSpaces(safeLower(text))
    .replace(/\b(met[àa]\s*e\s*met[àa]|mezza\s+e\s+mezza|1\/2)\b/g,'')
    .replace(/\b(senza\s+glutine|sg|s\.g\.)\b/g,'')
    .replace(/\b(impasto|formato|pizza|pizze)\b/g,'')
    .replace(/\+.*$/g,'')
    .trim();

  // match diretto per chiavi note
  const keys = Object.keys(cat.pizzas||{}).sort((a,b)=>b.length-a.length);
  for(const k of keys){
    if(t.includes(safeLower(k))) return k;
  }

  const alias = resolveAlias(cat, t);
  if(cat.pizzas && cat.pizzas[alias] != null) return alias;

  return t || text.trim();
}

function isDrinkLine(cat, text){
  const t = normSpaces(safeLower(text));
  const alias = resolveAlias(cat, t);
  if(cat.drinks && cat.drinks[alias] != null) return alias;
  for(const k of Object.keys(cat.drinks||{})){
    if(t.includes(safeLower(k))) return k;
  }
  return "";
}

/* ---------------- Pricing ---------------- */
function extrasSum(cat, extras){
  return (extras||[]).reduce((acc, ex)=>{
    const k = resolveAlias(cat, ex);
    const p = (cat.extras && cat.extras[k] != null) ? Number(cat.extras[k]) : 0;
    return acc + p;
  }, 0);
}
function pricePizza(cat, pizzaKey, doughKey, sizeKey, extras){
  const baseKnown = (cat.pizzas && cat.pizzas[pizzaKey] != null);
  const base = baseKnown ? Number(cat.pizzas[pizzaKey]) : 0;
  const dough = (cat.doughs && cat.doughs[doughKey] != null) ? Number(cat.doughs[doughKey]) : 0;
  const size  = (cat.sizes && cat.sizes[sizeKey] != null) ? Number(cat.sizes[sizeKey]) : 0;
  return { unit: base + dough + size + extrasSum(cat, extras), known: baseKnown };
}
function priceHalfHalf(cat, aKey, bKey, doughKey, sizeKey, extras){
  const aKnown = (cat.pizzas && cat.pizzas[aKey] != null);
  const bKnown = (cat.pizzas && cat.pizzas[bKey] != null);
  const a = aKnown ? Number(cat.pizzas[aKey]) : 0;
  const b = bKnown ? Number(cat.pizzas[bKey]) : 0;

  const rule = cat.rules?.halfHalfPricing || "max";
  const base = (rule === "avg") ? (a+b)/2 : Math.max(a,b);

  const dough = (cat.doughs && cat.doughs[doughKey] != null) ? Number(cat.doughs[doughKey]) : 0;
  const size  = (cat.sizes && cat.sizes[sizeKey] != null) ? Number(cat.sizes[sizeKey]) : 0;

  let ex = extrasSum(cat, extras);
  const exRule = cat.rules?.halfHalfExtras || "full";
  if(exRule === "half") ex = ex/2;

  return { unit: base + dough + size + ex, known: (aKnown || bKnown) };
}

/* ---------------- Parse order ---------------- */
function parseOrder(cat, text){
  const rawLines = text.replace(/\r/g,'').split('\n').map(l => stripChatNoise(l)).filter(Boolean);
  const lines = rawLines.map(l => l.trim()).filter(l => l.length);

  // labeled fields
  let name = extractLabeled(text, "Nome") || "";
  let address = extractLabeled(text, "Indirizzo") || "";
  let bell = extractLabeled(text, "Campanello") || "";

  // other fields
  let phone = "";
  let desiredTime = "";
  let requestedTotal = null;
  let mode = detectPickupDelivery(text);

  // if address not labeled, detect from lines
  for(const line of lines){
    if(!phone){
      const pm = line.match(/(\+?\d[\d\s\-]{6,}\d)/);
      if(pm) phone = pm[1].replace(/[^\d+]/g,'');
    }
    if(!desiredTime){
      const tm = line.match(/(?:per\s*le\s*)?(\d{1,2}[.:]\d{2})/i);
      if(tm) desiredTime = normalizeTime(tm[1]);
    }
    if(requestedTotal === null){
      const qm = line.match(/\b(\d{1,2})\s*pizz[ae]\b/i);
      if(qm) requestedTotal = Number(qm[1]);
    }
    if(!address && looksLikeAddress(line)){
      address = line.replace(/^indirizzo\s*:\s*/i,'').trim();
    }
    // se non c'è "Nome:" e la riga sembra un nome (breve) possiamo lasciar perdere: meglio non inventare.
  }

  // items
  const items = [];

  // 1) inline "3 pizze margherita"
  const inline = findInlinePizzaStatements(cat, text);
  for(const it of inline){
    const p = pricePizza(cat, it.nameKey, "classico", "normale", []);
    items.push({
      kind:"pizza", qty: it.qty,
      halfHalf:false, pizzaKey: it.nameKey,
      doughKey:"classico", sizeKey:"normale",
      extras:[], removals:[],
      glutenFree:false,
      unitPrice: p.unit, lineTotal: p.unit*it.qty,
      priceKnown: p.known
    });
  }

  // 2) line-by-line items
  for(const line0 of lines){
    const line = line0.trim();
    if(!line) continue;

    // Skip headers / polite text / labeled fields
    if(/^(ciao|buonasera|buongiorno|salve)\b/i.test(line)) continue;
    if(/^nome\s*:/i.test(line)) continue;
    if(/^indirizzo\s*:/i.test(line)) continue;
    if(/^campanello\s*:/i.test(line)) continue;
    if(looksLikeAddress(line) && !/^(\d+)\s+/.test(line)) continue;
    if(/\bvorrei\b/i.test(line) && /\bpizz[ae]\b/i.test(line)) continue;
    if(/\battendo\b/i.test(line) || /\bconferma\b/i.test(line) || /\bgrazie\b/i.test(line)) continue;

    const {qty, text: itemText} = extractQtyAndText(line);

    // Drinks
    const drinkKey = isDrinkLine(cat, itemText);
    if(drinkKey){
      const unit = Number(cat.drinks[drinkKey] || 0);
      items.push({ kind:"drink", qty, label:drinkKey, unitPrice:unit, lineTotal:unit*qty, priceKnown: (cat.drinks[drinkKey]!=null) });
      continue;
    }

    // Pizza
    const doughKey = detectDough(cat, itemText);
    const sizeKey = detectSize(cat, itemText);
    const {extras, removals} = parseExtrasAndRemovals(cat, itemText);
    const half = parseHalfHalf(itemText);

    if(half){
      const aKey = findPizzaName(cat, half.a);
      const bKey = findPizzaName(cat, half.b);
      const pr = priceHalfHalf(cat, aKey, bKey, doughKey, sizeKey, extras);
      items.push({
        kind:"pizza", qty, halfHalf:true, aKey, bKey,
        doughKey, sizeKey, extras, removals,
        glutenFree: doughKey==="senza glutine",
        unitPrice: pr.unit, lineTotal: pr.unit*qty,
        priceKnown: pr.known
      });
    } else {
      const pizzaKey = findPizzaName(cat, itemText);
      const pr = pricePizza(cat, pizzaKey, doughKey, sizeKey, extras);
      items.push({
        kind:"pizza", qty, halfHalf:false, pizzaKey,
        doughKey, sizeKey, extras, removals,
        glutenFree: doughKey==="senza glutine",
        unitPrice: pr.unit, lineTotal: pr.unit*qty,
        priceKnown: pr.known
      });
    }
  }

  // Totals
  const computedPizzas = items.filter(i=>i.kind==="pizza").reduce((a,i)=>a+i.qty,0);
  let total = items.reduce((a,i)=>a+i.lineTotal,0);

  // Delivery fee
  const deliveryFee = Number(cat.rules?.deliveryFee || 0);
  const addDelivery = (mode === "CONSEGNA") || (mode.includes("CONSEGNA") && !mode.includes("/"));
  if(addDelivery && deliveryFee>0) total += deliveryFee;

  return { name, phone, address, bell, desiredTime, requestedTotal, computedPizzas, mode, items, total, deliveryFee:(addDelivery?deliveryFee:0) };
}

/* ---------------- Format outputs ---------------- */
function fmtKitchen(cat, o){
  const sep = "--------------------------------";
  const head = [
    "================================",
    "          COMANDA CUCINA        ",
    "================================",
    `Ora: ${nowStr()}`,
    o.desiredTime ? `Orario: ${o.desiredTime}` : "Orario: —",
    `Tipo: ${o.mode || "—"}`,
    o.name ? `Cliente: ${o.name}` : "Cliente: —",
    o.phone ? `Tel: ${o.phone}` : "",
    o.address ? `Indirizzo: ${o.address}` : "Indirizzo: —",
    o.bell ? `Campanello: ${o.bell}` : "",
    sep,
    "ARTICOLI:"
  ].filter(Boolean);

  const body = (o.items.length?o.items:[]).map(it=>{
    if(it.kind==="drink"){
      return `${String(it.qty).padStart(2,' ')}  BIBITA  ${it.label}`;
    }
    const gf = it.glutenFree ? "  !!! SENZA GLUTINE !!!" : "";
    const size = (it.sizeKey!=="normale") ? ` (${it.sizeKey})` : "";
    const dough = (it.doughKey!=="classico") ? ` {${it.doughKey}}` : "";
    const extras = (it.extras?.length) ? ` +${it.extras.join(", ")}` : "";
    const rem = (it.removals?.length) ? ` -${it.removals.join(", ")}` : "";
    const name = it.halfHalf ? `½ ${it.aKey} / ½ ${it.bKey}` : it.pizzaKey;
    return `${String(it.qty).padStart(2,' ')}  ${name}${size}${dough}${extras}${rem}${gf}`;
  }).join("\n");

  const warn = (o.requestedTotal!==null && o.computedPizzas && o.requestedTotal !== o.computedPizzas)
    ? `⚠️ dichiarate ${o.requestedTotal} / trovate ${o.computedPizzas}`
    : "";

  const foot = [
    sep,
    `Totale pizze: ${o.computedPizzas}` + (o.requestedTotal!==null?` (dichiarate: ${o.requestedTotal})`:""),
    warn,
    "================================"
  ].filter(Boolean);

  return [...head, body || "—", ...foot].join("\n");
}

function fmtReceipt(cat, o){
  const cur = cat.currency || "€";
  const sep = "--------------------------------";
  const lines = [];

  lines.push("================================");
  lines.push("         RICEVUTA CLIENTE       ");
  lines.push("================================");
  lines.push(`Ora: ${nowStr()}`);
  if(o.desiredTime) lines.push(`Orario: ${o.desiredTime}`);
  lines.push(`Tipo: ${o.mode || "—"}`);
  if(o.name) lines.push(`Cliente: ${o.name}`);
  if(o.phone) lines.push(`Tel: ${o.phone}`);
  if(o.address) lines.push(`Indirizzo: ${o.address}`);
  if(o.bell) lines.push(`Campanello: ${o.bell}`);
  lines.push(sep);

  let missing = 0;

  for(const it of o.items){
    if(it.kind==="drink"){
      lines.push(`${it.qty} x ${it.label}`);
      if(!it.priceKnown){ missing++; lines.push(`   ⚠️ PREZZO NON TROVATO`); }
      else lines.push(`   ${money(it.unitPrice)}${cur} -> ${money(it.lineTotal)}${cur}`);
      lines.push(sep);
      continue;
    }
    const name = it.halfHalf ? `½ ${it.aKey} / ½ ${it.bKey}` : it.pizzaKey;
    const gf = it.glutenFree ? " [SENZA GLUTINE]" : "";
    const size = (it.sizeKey!=="normale") ? ` (${it.sizeKey})` : "";
    const dough = (it.doughKey!=="classico") ? ` {${it.doughKey}}` : "";
    const extras = (it.extras?.length) ? ` +${it.extras.join(", ")}` : "";
    const rem = (it.removals?.length) ? ` -${it.removals.join(", ")}` : "";
    lines.push(`${it.qty} x ${name}${size}${dough}${gf}${extras}${rem}`);
    if(!it.priceKnown){ missing++; lines.push(`   ⚠️ PREZZO NON TROVATO`); }
    else lines.push(`   ${money(it.unitPrice)}${cur} -> ${money(it.lineTotal)}${cur}`);
    lines.push(sep);
  }

  if(o.deliveryFee && o.deliveryFee>0){
    lines.push(`CONSEGNA`);
    lines.push(`   ${money(o.deliveryFee)}${cur}`);
    lines.push(sep);
  }

  lines.push(`TOTALE: ${money(o.total)}${cur}`);
  if(missing>0) lines.push(`⚠️ ${missing} riga/e senza prezzo: aggiorna il catalogo.`);
  lines.push("================================");
  return lines.join("\n");
}

/* ---------------- UI wiring ---------------- */
let CATALOG = loadCatalog();
setCatalogTextarea(CATALOG);
ensureDaily();

function renderAll(){
  ensureDaily();
  const text = document.getElementById("input").value || "";
  if(!text.trim()){
    document.getElementById("outKitchen").textContent = "—";
    document.getElementById("outReceipt").textContent = "—";
    setStatus("", "");
    return;
  }
  const o = parseOrder(CATALOG, text);
  document.getElementById("outKitchen").textContent = fmtKitchen(CATALOG, o);
  document.getElementById("outReceipt").textContent = fmtReceipt(CATALOG, o);
  setStatus("Generato.", "ok");
}

document.getElementById("gen").addEventListener("click", renderAll);

document.getElementById("copy").addEventListener("click", async () => {
  const kitchen = document.getElementById("outKitchen").textContent;
  const receipt = document.getElementById("outReceipt").textContent;
  const combined = kitchen + "\n\n" + receipt;
  if(!combined || combined.startsWith("—")) return;
  try{
    await navigator.clipboard.writeText(combined);
    setStatus("Copiato (comanda + ricevuta).", "ok");
  }catch{
    setStatus("Copia automatica non disponibile: copia manualmente.", "warn");
  }
});

document.getElementById("print").addEventListener("click", () => window.print());

document.getElementById("closeDay").addEventListener("click", () => {
  document.getElementById("input").value = "";
  document.getElementById("outKitchen").textContent = "—";
  document.getElementById("outReceipt").textContent = "—";
  localStorage.setItem(LS.lastDay, todayKey());
  setStatus("Chiusura serale: pulito.", "ok");
});

document.getElementById("saveCatalog").addEventListener("click", () => {
  const el = document.getElementById("catStatus");
  try{
    const obj = JSON.parse(document.getElementById("catalog").value);
    saveCatalog(obj);
    CATALOG = obj;
    el.className = "small ok";
    el.textContent = "Catalogo salvato.";
    setStatus("Catalogo aggiornato.", "ok");
  }catch{
    el.className = "small warn";
    el.textContent = "Errore JSON: controlla virgole/virgolette.";
    setStatus("Errore nel catalogo JSON.", "warn");
  }
});

document.getElementById("resetCatalog").addEventListener("click", () => {
  CATALOG = structuredClone(SAMPLE_CATALOG);
  setCatalogTextarea(CATALOG);
  saveCatalog(CATALOG);
  document.getElementById("catStatus").className = "small ok";
  document.getElementById("catStatus").textContent = "Ripristinato esempio.";
  setStatus("Catalogo ripristinato.", "ok");
});

// Tabs
for(const t of document.querySelectorAll(".tab")){
  t.addEventListener("click", () => {
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    const view = t.getAttribute("data-view");
    document.getElementById("outKitchen").style.display = (view==="kitchen") ? "block" : "none";
    document.getElementById("outReceipt").style.display = (view==="receipt") ? "block" : "none";
  });
}
</script>
</body>
</html>
